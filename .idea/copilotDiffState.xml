<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/utils/parseBaseExamples.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/utils/parseBaseExamples.ts" />
              <option name="originalContent" value="import type { BaseExample } from '../examples/types'&#10;&#10;export class ExampleBlock {&#10;    pageTitle: string | null;&#10;    sectionTitle: string | null;&#10;&#10;    private _descriptionLines: string[];&#10;    private _codeLines: string[];&#10;    private _outputLines: string[];&#10;&#10;    constructor(pageTitle: string | null = null, sectionTitle: string | null = null) {&#10;        this.pageTitle = pageTitle;&#10;        this.sectionTitle = sectionTitle;&#10;        this._descriptionLines = [];&#10;        this._codeLines = [];&#10;        this._outputLines = [];&#10;    }&#10;&#10;    static createEmpty(): ExampleBlock {&#10;        return new ExampleBlock(null, null);&#10;    }&#10;&#10;    static create({ pageTitle = null, sectionTitle = null, description = '', codeExample = '', output = '' }: {&#10;        pageTitle?: string | null;&#10;        sectionTitle?: string | null;&#10;        description?: string;&#10;        codeExample?: string;&#10;        output?: string;&#10;    }): ExampleBlock {&#10;        const b = new ExampleBlock(pageTitle, sectionTitle);&#10;        if (description &amp;&amp; description.length &gt; 0) {&#10;            b.setDescription(description);&#10;        }&#10;        if (codeExample &amp;&amp; codeExample.length &gt; 0) {&#10;            b.setCode(codeExample);&#10;        }&#10;        if (output &amp;&amp; output.length &gt; 0) {&#10;            b.setOutput(output);&#10;        }&#10;        return b;&#10;    }&#10;&#10;    hasContent(): boolean {&#10;        if (this._codeLines.length &gt; 0) return true;&#10;        if (this._outputLines.some((l) =&gt; l.trim().length &gt; 0)) return true;&#10;        return this._descriptionLines.some((l) =&gt; l.trim().length &gt; 0);&#10;    }&#10;&#10;    // Helpers used by the parser&#10;    addDescriptionLine(line: string): void {&#10;        this._descriptionLines.push(line);&#10;    }&#10;&#10;    addBlankParagraph(): void {&#10;        this._descriptionLines.push('\n\n\n');&#10;    }&#10;&#10;    setDescription(description: string): void {&#10;        this._descriptionLines = [description];&#10;    }&#10;&#10;    clearDescription(): void {&#10;        this._descriptionLines = [];&#10;    }&#10;&#10;    addCodeLine(line: string): void {&#10;        this._codeLines.push(line);&#10;    }&#10;&#10;    setCode(code: string): void {&#10;        this._codeLines = code.split('\n');&#10;    }&#10;&#10;    clearCode(): void {&#10;        this._codeLines = [];&#10;    }&#10;&#10;    addOutputLine(line: string): void {&#10;        this._outputLines.push(line);&#10;    }&#10;&#10;    setOutput(output: string): void {&#10;        this._outputLines = output.split('\n');&#10;    }&#10;&#10;    clearOutput(): void {&#10;        this._outputLines = [];&#10;    }&#10;&#10;    trimCodeEdges(): void {&#10;        while (this._codeLines.length &gt; 0 &amp;&amp; (this._codeLines[0] ?? '').trim() === '') this._codeLines.shift();&#10;        while (this._codeLines.length &gt; 0 &amp;&amp; (this._codeLines[this._codeLines.length - 1] ?? '').trim() === '') this._codeLines.pop();&#10;    }&#10;&#10;    get description(): string {&#10;        return this._descriptionLines.join(' ');&#10;    }&#10;&#10;    get codeExample(): string {&#10;        return this._codeLines.join('\n');&#10;    }&#10;&#10;    getOutput(): string {&#10;        return this._outputLines.join('\n');&#10;    }&#10;}&#10;&#10;/**&#10; * Parse BASE_EXAMPLES.md into structured blocks.&#10; * A new block is created for each fenced code block, with context derived from the nearest preceding headings.&#10; */&#10;export function parseBaseExamplesMarkdown(markdown: string): ExampleBlock[] {&#10;    const lines = markdown.split(/\r?\n/);&#10;    const blocks: ExampleBlock[] = [];&#10;&#10;    let pageTitle: string | null = null;&#10;    let sectionTitle: string | null = null;&#10;    let inCode = false;&#10;    let isOutputSection = false;&#10;    let fenceLang: string | null = null;&#10;    let pendingPush = false; // true when we've just closed an edgerules block and await possible output&#10;&#10;    // Current block we're filling&#10;    let current = ExampleBlock.createEmpty();&#10;&#10;    const pushBlock = (): void =&gt; {&#10;        // If there's nothing meaningful in this block (no desc/code/output), just reset context&#10;        if (!current.hasContent()) {&#10;            current = ExampleBlock.createEmpty();&#10;            current.pageTitle = pageTitle;&#10;            current.sectionTitle = sectionTitle;&#10;            pendingPush = false;&#10;            return;&#10;        }&#10;&#10;        // push a copy of current to avoid later mutation&#10;        blocks.push(ExampleBlock.create({&#10;            pageTitle: current.pageTitle,&#10;            sectionTitle: current.sectionTitle,&#10;            description: current.description,&#10;            codeExample: current.codeExample,&#10;            output: current.getOutput(),&#10;        }));&#10;&#10;        // reset&#10;        current = ExampleBlock.createEmpty();&#10;        current.pageTitle = pageTitle;&#10;        current.sectionTitle = sectionTitle;&#10;        pendingPush = false;&#10;    };&#10;&#10;    for (let i = 0; i &lt; lines.length; i += 1) {&#10;        const line = (lines[i] ?? '');&#10;&#10;        const fenceMatch = line.match(/^```(\w+)?\s*$/);&#10;        if (fenceMatch) {&#10;            const lang = (fenceMatch[1] ?? '').toLowerCase() || null;&#10;            if (!inCode) {&#10;                // Opening fence&#10;                inCode = true;&#10;                fenceLang = lang;&#10;                // If this is a JSON fence and we are in an output section, treat it as output collection&#10;                // Otherwise if it's edgerules, we collect code. Other languages we'll treat as generic code (ignored by UI).&#10;                continue;&#10;            }&#10;&#10;            // Closing fence. Which kind did we close?&#10;            if (!fenceLang) {&#10;                // unknown fence, just toggle&#10;                inCode = false;&#10;                fenceLang = null;&#10;                continue;&#10;            }&#10;&#10;            // If we were collecting JSON output inside an output section, closing it finalizes the block&#10;            if (fenceLang === 'json' &amp;&amp; isOutputSection) {&#10;                inCode = false;&#10;                fenceLang = null;&#10;                // finished collecting output for this block -&gt; finalize&#10;                pushBlock();&#10;                isOutputSection = false;&#10;                continue;&#10;            }&#10;&#10;            // If we were collecting edgerules code, closing it means code is complete; defer pushing in case output follows&#10;            if (fenceLang === 'edgerules') {&#10;                inCode = false;&#10;                fenceLang = null;&#10;                current.trimCodeEdges();&#10;                pendingPush = true; // wait for possible output: marker&#10;                continue;&#10;            }&#10;&#10;            // Any other fence closed - just stop collecting inCode&#10;            inCode = false;&#10;            fenceLang = null;&#10;            continue;&#10;        }&#10;&#10;        if (!inCode) {&#10;            // Only support # and ## as structural headings. ### is treated as regular content.&#10;            const heading = line.match(/^(#{1,2})\s+(.+)/);&#10;            if (heading &amp;&amp; heading[1] &amp;&amp; heading[2]) {&#10;                // If we had a pending block (closed edgerules with no output), finalize it now&#10;                if (pendingPush) {&#10;                    pushBlock();&#10;                }&#10;&#10;                pushBlock();&#10;                const level = heading[1].length; // 1 or 2&#10;                const text = heading[2].trim();&#10;                if (level === 1) {&#10;                    pageTitle = text;&#10;                    sectionTitle = null;&#10;                } else {&#10;                    sectionTitle = text;&#10;                }&#10;                isOutputSection = false;&#10;                current.pageTitle = pageTitle;&#10;                current.sectionTitle = sectionTitle;&#10;                continue;&#10;            }&#10;&#10;            // contains only the word &quot;output:&quot; or &quot;**output:**&quot;&#10;            if (line.match(/^output:\s*$/i) || line.match(/^\*\*output:\*\*\s*$/i)) {&#10;                // start collecting output lines for the current block&#10;                isOutputSection = true;&#10;                // clear any previous output capture for this block&#10;                current.clearOutput();&#10;                continue;&#10;            }&#10;&#10;            // If we were waiting for output but encounter non-output content, finalize the pending block now&#10;            if (pendingPush &amp;&amp; !isOutputSection &amp;&amp; line.trim() !== '') {&#10;                pushBlock();&#10;            }&#10;&#10;            if (isOutputSection) {&#10;                // non-fenced output lines (rare); collect as output text&#10;                current.addOutputLine(line);&#10;                continue;&#10;            }&#10;        }&#10;&#10;        if (inCode) {&#10;            // Route code lines based on the active fence language&#10;            if (fenceLang === 'edgerules') {&#10;                current.addCodeLine(line);&#10;            } else if (fenceLang === 'json' &amp;&amp; isOutputSection) {&#10;                current.addOutputLine(line);&#10;            } else {&#10;                // other fenced content - treat as description/code: append to description to be safe&#10;                current.addDescriptionLine(line);&#10;            }&#10;        } else {&#10;            if (line.trim() === '' &amp;&amp; !current.hasContent()) {&#10;                continue;&#10;            }&#10;&#10;            // starts with -&#10;            const listMatch = line.match(/^\s*-\s+(.*)/);&#10;            if (listMatch) {&#10;                // remove - and replace with bullet&#10;                let trimmed = line.replace(/^\s*-\s+/, '• ');&#10;                current.addDescriptionLine(trimmed);&#10;                current.addBlankParagraph();&#10;                continue;&#10;            }&#10;&#10;            if (line.trim() === '' &amp;&amp; current.hasContent()) {&#10;                current.addBlankParagraph();&#10;                continue;&#10;            }&#10;&#10;            // By default treat the line as description text. This also captures ### headings (no subtitle support).&#10;            current.addDescriptionLine(line);&#10;        }&#10;    }&#10;&#10;    // If we ended while waiting for output or after closing edgerules with no further content, finalize&#10;    if (pendingPush || current.hasContent()) {&#10;        pushBlock();&#10;    }&#10;&#10;    return blocks;&#10;}&#10;&#10;/** Public content menu configuration item. */&#10;export interface MarkdownContentMenuItem {&#10;    menuTitle: string;&#10;    type?: 'markdown';&#10;    contentReference: string; // relative path under public/, e.g., &quot;BASE_EXAMPLES.md&quot;&#10;}&#10;&#10;export interface PlaygroundContentMenuItem {&#10;    menuTitle: string;&#10;    type: 'playground';&#10;}&#10;&#10;export type ContentMenuItem = MarkdownContentMenuItem | PlaygroundContentMenuItem;&#10;&#10;export function isMarkdownContentMenuItem(item: ContentMenuItem): item is MarkdownContentMenuItem {&#10;    return (item as MarkdownContentMenuItem).contentReference !== undefined;&#10;}&#10;&#10;/** Compute the app base URL from Vite env, normalized with trailing slash. */&#10;export function getBaseUrl(): string {&#10;    const globalBase = typeof globalThis !== 'undefined'&#10;        ? (globalThis as typeof globalThis &amp; { __VITE_BASE_URL__?: unknown }).__VITE_BASE_URL__&#10;        : undefined&#10;    const val = typeof globalBase === 'string' &amp;&amp; globalBase.length &gt; 0 ? globalBase : '/'&#10;    return val.endsWith('/') ? val : `${val}/`&#10;}&#10;&#10;/** Create a slug id from a title. */&#10;export function toSlug(s: string): string {&#10;    return s.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-+|-+$/g, '')&#10;}&#10;&#10;/** Map parsed blocks to BaseExample records. */&#10;export function mapBlocksToBaseExamples(blocks: ExampleBlock[]): BaseExample[] {&#10;    return blocks.map((b, idx): BaseExample =&gt; {&#10;        const title = b.sectionTitle&#10;            ? b.sectionTitle&#10;            : (b.pageTitle ?? `Example ${idx + 1}`)&#10;        const idBase = b.sectionTitle&#10;            ? b.sectionTitle&#10;            : (b.pageTitle ?? `example-${idx + 1}`)&#10;        const id = toSlug(idBase)&#10;        return { id, title, description: b.description, codeExample: b.codeExample }&#10;    })&#10;}&#10;&#10;/** Fetch a markdown file from public by relative reference. */&#10;export async function fetchMarkdown(reference: string): Promise&lt;string&gt; {&#10;    // Prefer relative fetch for correct resolution under Vite base path in dev/prod&#10;    const normalized = reference.replace(/^\/+/, '')&#10;&#10;    const tryUrls: string[] = [normalized]&#10;    // Fallback to explicit base prefix if relative path fails in some hosting setups&#10;    const base = getBaseUrl()&#10;    if (base &amp;&amp; base !== '/' &amp;&amp; !base.endsWith(normalized)) {&#10;        tryUrls.push(`${base}${normalized}`)&#10;    }&#10;&#10;    let lastStatus: string | number = 'unknown'&#10;    for (const url of tryUrls) {&#10;        try {&#10;            const resp = await fetch(url)&#10;            if (resp.ok) return await resp.text()&#10;            lastStatus = resp.status&#10;        } catch (e) {&#10;            lastStatus = (e as Error)?.message || String(e)&#10;        }&#10;    }&#10;    throw new Error(`Failed to fetch ${reference}: ${lastStatus}`)&#10;}&#10;&#10;/** Fetch a markdown page and return mapped BaseExamples. */&#10;export async function fetchAndParseBaseExamples(reference: string): Promise&lt;BaseExample[]&gt; {&#10;    const md = await fetchMarkdown(reference)&#10;    const blocks = parseBaseExamplesMarkdown(md)&#10;    return mapBlocksToBaseExamples(blocks)&#10;}&#10;&#10;// Pretty objects, but NEVER wrap arrays (inline them).&#10;export function stringifyNoWrapLists(value: unknown, indent = 2): string {&#10;    const pad = (n: number) =&gt; ' '.repeat(n * indent);&#10;&#10;    const prim = (v: unknown) =&gt;&#10;        v === null || ['string', 'number', 'boolean'].includes(typeof v);&#10;&#10;    const fmt = (v: unknown, lvl: number): string =&gt; {&#10;        if (v === null) return 'null';&#10;        const t = typeof v;&#10;&#10;        if (t === 'string') return JSON.stringify(v);&#10;        if (t === 'number' || t === 'boolean') return String(v);&#10;        if (t === 'bigint') return `&quot;${String(v)}&quot;`; // keep JSON-safe&#10;&#10;        if (Array.isArray(v)) {&#10;            // Always inline arrays&#10;            const parts = v.map((x) =&gt;&#10;                prim(x) ? fmt(x, 0) : fmt(x, lvl + 1) // complex items still allowed&#10;            );&#10;            // If any complex item expanded to multi-line, keep commas with a space&#10;            return `[${parts.join(', ')}]`;&#10;        }&#10;&#10;        if (t === 'object') {&#10;            const o = v as Record&lt;string, unknown&gt;;&#10;            const keys = Object.keys(o);&#10;            if (keys.length === 0) return '{}';&#10;            const body = keys&#10;                .map((k) =&gt; `${JSON.stringify(k)}: ${fmt(o[k], lvl + 1)}`)&#10;                .map((line) =&gt; pad(lvl + 1) + line)&#10;                .join('\n');&#10;            return `{\n${body}\n${pad(lvl)}}`;&#10;        }&#10;&#10;        // functions/symbol/undefined -&gt; stringify safely&#10;        return JSON.stringify(String(v));&#10;    };&#10;&#10;    return fmt(value, 0);&#10;}&#10;&#10;// Use it in your existing function&#10;export function formatWasmResult(value: unknown): string {&#10;    if (value === undefined || value === null) return '';&#10;    if (typeof value === 'string') return value;&#10;    if (typeof value === 'number' || typeof value === 'boolean' || typeof value === 'bigint') {&#10;        return String(value);&#10;    }&#10;    if (value instanceof Error) return value.message;&#10;&#10;    try {&#10;        return stringifyNoWrapLists(value, 2);&#10;    } catch {&#10;        return String(value);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="import type { BaseExample } from '../examples/types'&#10;&#10;export class ExampleBlock {&#10;    pageTitle: string | null;&#10;    sectionTitle: string | null;&#10;&#10;    private _descriptionLines: string[];&#10;    private _codeLines: string[];&#10;    private _outputLines: string[];&#10;&#10;    constructor(pageTitle: string | null = null, sectionTitle: string | null = null) {&#10;        this.pageTitle = pageTitle;&#10;        this.sectionTitle = sectionTitle;&#10;        this._descriptionLines = [];&#10;        this._codeLines = [];&#10;        this._outputLines = [];&#10;    }&#10;&#10;    static createEmpty(): ExampleBlock {&#10;        return new ExampleBlock(null, null);&#10;    }&#10;&#10;    static create({ pageTitle = null, sectionTitle = null, description = '', codeExample = '', output = '' }: {&#10;        pageTitle?: string | null;&#10;        sectionTitle?: string | null;&#10;        description?: string;&#10;        codeExample?: string;&#10;        output?: string;&#10;    }): ExampleBlock {&#10;        const b = new ExampleBlock(pageTitle, sectionTitle);&#10;        if (description &amp;&amp; description.length &gt; 0) {&#10;            b.setDescription(description);&#10;        }&#10;        if (codeExample &amp;&amp; codeExample.length &gt; 0) {&#10;            b.setCode(codeExample);&#10;        }&#10;        if (output &amp;&amp; output.length &gt; 0) {&#10;            b.setOutput(output);&#10;        }&#10;        return b;&#10;    }&#10;&#10;    hasContent(): boolean {&#10;        if (this._codeLines.length &gt; 0) return true;&#10;        if (this._outputLines.some((l) =&gt; l.trim().length &gt; 0)) return true;&#10;        return this._descriptionLines.some((l) =&gt; l.trim().length &gt; 0);&#10;    }&#10;&#10;    // Helpers used by the parser&#10;    addDescriptionLine(line: string): void {&#10;        this._descriptionLines.push(line);&#10;    }&#10;&#10;    addBlankParagraph(): void {&#10;        this._descriptionLines.push('\n\n\n');&#10;    }&#10;&#10;    setDescription(description: string): void {&#10;        this._descriptionLines = [description];&#10;    }&#10;&#10;    clearDescription(): void {&#10;        this._descriptionLines = [];&#10;    }&#10;&#10;    addCodeLine(line: string): void {&#10;        this._codeLines.push(line);&#10;    }&#10;&#10;    setCode(code: string): void {&#10;        this._codeLines = code.split('\n');&#10;    }&#10;&#10;    clearCode(): void {&#10;        this._codeLines = [];&#10;    }&#10;&#10;    addOutputLine(line: string): void {&#10;        this._outputLines.push(line);&#10;    }&#10;&#10;    setOutput(output: string): void {&#10;        this._outputLines = output.split('\n');&#10;    }&#10;&#10;    clearOutput(): void {&#10;        this._outputLines = [];&#10;    }&#10;&#10;    trimCodeEdges(): void {&#10;        while (this._codeLines.length &gt; 0 &amp;&amp; (this._codeLines[0] ?? '').trim() === '') this._codeLines.shift();&#10;        while (this._codeLines.length &gt; 0 &amp;&amp; (this._codeLines[this._codeLines.length - 1] ?? '').trim() === '') this._codeLines.pop();&#10;    }&#10;&#10;    get description(): string {&#10;        return this._descriptionLines.join(' ');&#10;    }&#10;&#10;    get codeExample(): string {&#10;        return this._codeLines.join('\n');&#10;    }&#10;&#10;    getOutput(): string {&#10;        return this._outputLines.join('\n');&#10;    }&#10;}&#10;&#10;/**&#10; * Parse BASE_EXAMPLES.md into structured blocks.&#10; * A new block is created for each fenced code block, with context derived from the nearest preceding headings.&#10; */&#10;export function parseBaseExamplesMarkdown(markdown: string): ExampleBlock[] {&#10;    const lines = markdown.split(/\r?\n/);&#10;    const blocks: ExampleBlock[] = [];&#10;&#10;    let pageTitle: string | null = null;&#10;    let sectionTitle: string | null = null;&#10;    let inCode = false;&#10;    let isOutputSection = false;&#10;    let fenceLang: string | null = null;&#10;    let pendingPush = false; // true when we've just closed an edgerules block and await possible output&#10;&#10;    // Current block we're filling&#10;    let current = ExampleBlock.createEmpty();&#10;&#10;    const pushBlock = (): void =&gt; {&#10;        // If there's nothing meaningful in this block (no desc/code/output), just reset context&#10;        if (!current.hasContent()) {&#10;            current = ExampleBlock.createEmpty();&#10;            current.pageTitle = pageTitle;&#10;            current.sectionTitle = sectionTitle;&#10;            pendingPush = false;&#10;            return;&#10;        }&#10;&#10;        // push a copy of current to avoid later mutation&#10;        blocks.push(ExampleBlock.create({&#10;            pageTitle: current.pageTitle,&#10;            sectionTitle: current.sectionTitle,&#10;            description: current.description,&#10;            codeExample: current.codeExample,&#10;            output: current.getOutput(),&#10;        }));&#10;&#10;        // reset&#10;        current = ExampleBlock.createEmpty();&#10;        current.pageTitle = pageTitle;&#10;        current.sectionTitle = sectionTitle;&#10;        pendingPush = false;&#10;    };&#10;&#10;    for (let i = 0; i &lt; lines.length; i += 1) {&#10;        const line = (lines[i] ?? '');&#10;&#10;        const fenceMatch = line.match(/^```(\w+)?\s*$/);&#10;        if (fenceMatch) {&#10;            const lang = (fenceMatch[1] ?? '').toLowerCase() || null;&#10;            if (!inCode) {&#10;                // Opening fence&#10;                inCode = true;&#10;                fenceLang = lang;&#10;                // If this is a JSON fence and we are in an output section, treat it as output collection&#10;                // Otherwise if it's edgerules, we collect code. Other languages we'll treat as generic code (ignored by UI).&#10;                continue;&#10;            }&#10;&#10;            // Closing fence. Which kind did we close?&#10;            if (!fenceLang) {&#10;                // unknown fence, just toggle&#10;                inCode = false;&#10;                fenceLang = null;&#10;                continue;&#10;            }&#10;&#10;            // If we were collecting JSON output inside an output section, closing it finalizes the block&#10;            if (fenceLang === 'json' &amp;&amp; isOutputSection) {&#10;                inCode = false;&#10;                fenceLang = null;&#10;                // finished collecting output for this block -&gt; finalize&#10;                pushBlock();&#10;                isOutputSection = false;&#10;                continue;&#10;            }&#10;&#10;            // If we were collecting edgerules code, closing it means code is complete; defer pushing in case output follows&#10;            if (fenceLang === 'edgerules') {&#10;                inCode = false;&#10;                fenceLang = null;&#10;                current.trimCodeEdges();&#10;                pendingPush = true; // wait for possible output: marker&#10;                continue;&#10;            }&#10;&#10;            // Any other fence closed - just stop collecting inCode&#10;            inCode = false;&#10;            fenceLang = null;&#10;            continue;&#10;        }&#10;&#10;        if (!inCode) {&#10;            // Only support # and ## as structural headings. ### is treated as regular content.&#10;            const heading = line.match(/^(#{1,2})\s+(.+)/);&#10;            if (heading &amp;&amp; heading[1] &amp;&amp; heading[2]) {&#10;                // If we had a pending block (closed edgerules with no output), finalize it now&#10;                if (pendingPush) {&#10;                    pushBlock();&#10;                }&#10;&#10;                // Finalize previous non-empty block before updating context&#10;                pushBlock();&#10;                const level = heading[1].length; // 1 or 2&#10;                const text = heading[2].trim();&#10;                if (level === 1) {&#10;                    pageTitle = text;&#10;                    sectionTitle = null;&#10;                } else {&#10;                    sectionTitle = text;&#10;                }&#10;                isOutputSection = false;&#10;                current.pageTitle = pageTitle;&#10;                current.sectionTitle = sectionTitle;&#10;                continue;&#10;            }&#10;&#10;            // contains only the word &quot;output:&quot; or &quot;**output:**&quot;&#10;            if (line.match(/^output:\s*$/i) || line.match(/^\*\*output:\*\*\s*$/i)) {&#10;                // start collecting output lines for the current block&#10;                isOutputSection = true;&#10;                // clear any previous output capture for this block&#10;                current.clearOutput();&#10;                continue;&#10;            }&#10;&#10;            // If we were waiting for output but encounter non-output content, finalize the pending block now&#10;            if (pendingPush &amp;&amp; !isOutputSection &amp;&amp; line.trim() !== '') {&#10;                pushBlock();&#10;            }&#10;&#10;            if (isOutputSection) {&#10;                // non-fenced output lines (rare); collect as output text&#10;                current.addOutputLine(line);&#10;                continue;&#10;            }&#10;        }&#10;&#10;        if (inCode) {&#10;            // Route code lines based on the active fence language&#10;            if (fenceLang === 'edgerules') {&#10;                current.addCodeLine(line);&#10;            } else if (fenceLang === 'json' &amp;&amp; isOutputSection) {&#10;                current.addOutputLine(line);&#10;            } else {&#10;                // other fenced content - treat as description/code: append to description to be safe&#10;                current.addDescriptionLine(line);&#10;            }&#10;        } else {&#10;            if (line.trim() === '' &amp;&amp; !current.hasContent()) {&#10;                continue;&#10;            }&#10;&#10;            // starts with -&#10;            const listMatch = line.match(/^\s*-\s+(.*)/);&#10;            if (listMatch) {&#10;                // remove - and replace with bullet&#10;                let trimmed = line.replace(/^\s*-\s+/, '• ');&#10;                current.addDescriptionLine(trimmed);&#10;                current.addBlankParagraph();&#10;                continue;&#10;            }&#10;&#10;            if (line.trim() === '' &amp;&amp; current.hasContent()) {&#10;                current.addBlankParagraph();&#10;                continue;&#10;            }&#10;&#10;            // By default treat the line as description text. This also captures ### headings (no subtitle support).&#10;            current.addDescriptionLine(line);&#10;        }&#10;    }&#10;&#10;    // If we ended while waiting for output or after closing edgerules with no further content, finalize&#10;    if (pendingPush || current.hasContent()) {&#10;        pushBlock();&#10;    }&#10;&#10;    return blocks;&#10;}&#10;&#10;/** Public content menu configuration item. */&#10;export interface MarkdownContentMenuItem {&#10;    menuTitle: string;&#10;    type?: 'markdown';&#10;    contentReference: string; // relative path under public/, e.g., &quot;BASE_EXAMPLES.md&quot;&#10;}&#10;&#10;export interface PlaygroundContentMenuItem {&#10;    menuTitle: string;&#10;    type: 'playground';&#10;}&#10;&#10;export type ContentMenuItem = MarkdownContentMenuItem | PlaygroundContentMenuItem;&#10;&#10;export function isMarkdownContentMenuItem(item: ContentMenuItem): item is MarkdownContentMenuItem {&#10;    return (item as MarkdownContentMenuItem).contentReference !== undefined;&#10;}&#10;&#10;/** Compute the app base URL from Vite env, normalized with trailing slash. */&#10;export function getBaseUrl(): string {&#10;    const globalBase = typeof globalThis !== 'undefined'&#10;        ? (globalThis as typeof globalThis &amp; { __VITE_BASE_URL__?: unknown }).__VITE_BASE_URL__&#10;        : undefined&#10;    const val = typeof globalBase === 'string' &amp;&amp; globalBase.length &gt; 0 ? globalBase : '/'&#10;    return val.endsWith('/') ? val : `${val}/`&#10;}&#10;&#10;/** Create a slug id from a title. */&#10;export function toSlug(s: string): string {&#10;    return s.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-+|-+$/g, '')&#10;}&#10;&#10;/** Map parsed blocks to BaseExample records. */&#10;export function mapBlocksToBaseExamples(blocks: ExampleBlock[]): BaseExample[] {&#10;    return blocks.map((b, idx): BaseExample =&gt; {&#10;        const title = b.sectionTitle&#10;            ? b.sectionTitle&#10;            : (b.pageTitle ?? `Example ${idx + 1}`)&#10;        const idBase = b.sectionTitle&#10;            ? b.sectionTitle&#10;            : (b.pageTitle ?? `example-${idx + 1}`)&#10;        const id = toSlug(idBase)&#10;        return { id, title, description: b.description, codeExample: b.codeExample }&#10;    })&#10;}&#10;&#10;/** Fetch a markdown file from public by relative reference. */&#10;export async function fetchMarkdown(reference: string): Promise&lt;string&gt; {&#10;    // Prefer relative fetch for correct resolution under Vite base path in dev/prod&#10;    const normalized = reference.replace(/^\/+/, '')&#10;&#10;    const tryUrls: string[] = [normalized]&#10;    // Fallback to explicit base prefix if relative path fails in some hosting setups&#10;    const base = getBaseUrl()&#10;    if (base &amp;&amp; base !== '/' &amp;&amp; !base.endsWith(normalized)) {&#10;        tryUrls.push(`${base}${normalized}`)&#10;    }&#10;&#10;    let lastStatus: string | number = 'unknown'&#10;    for (const url of tryUrls) {&#10;        try {&#10;            const resp = await fetch(url)&#10;            if (resp.ok) return await resp.text()&#10;            lastStatus = resp.status&#10;        } catch (e) {&#10;            lastStatus = (e as Error)?.message || String(e)&#10;        }&#10;    }&#10;    throw new Error(`Failed to fetch ${reference}: ${lastStatus}`)&#10;}&#10;&#10;/** Fetch a markdown page and return mapped BaseExamples. */&#10;export async function fetchAndParseBaseExamples(reference: string): Promise&lt;BaseExample[]&gt; {&#10;    const md = await fetchMarkdown(reference)&#10;    const blocks = parseBaseExamplesMarkdown(md)&#10;    return mapBlocksToBaseExamples(blocks)&#10;}&#10;&#10;// Pretty objects, but NEVER wrap arrays (inline them).&#10;export function stringifyNoWrapLists(value: unknown, indent = 2): string {&#10;    const pad = (n: number) =&gt; ' '.repeat(n * indent);&#10;&#10;    const prim = (v: unknown) =&gt;&#10;        v === null || ['string', 'number', 'boolean'].includes(typeof v);&#10;&#10;    const fmt = (v: unknown, lvl: number): string =&gt; {&#10;        if (v === null) return 'null';&#10;        const t = typeof v;&#10;&#10;        if (t === 'string') return JSON.stringify(v);&#10;        if (t === 'number' || t === 'boolean') return String(v);&#10;        if (t === 'bigint') return `&quot;${String(v)}&quot;`; // keep JSON-safe&#10;&#10;        if (Array.isArray(v)) {&#10;            // Always inline arrays&#10;            const parts = v.map((x) =&gt;&#10;                prim(x) ? fmt(x, 0) : fmt(x, lvl + 1) // complex items still allowed&#10;            );&#10;            // If any complex item expanded to multi-line, keep commas with a space&#10;            return `[${parts.join(', ')}]`;&#10;        }&#10;&#10;        if (t === 'object') {&#10;            const o = v as Record&lt;string, unknown&gt;;&#10;            const keys = Object.keys(o);&#10;            if (keys.length === 0) return '{}';&#10;            const body = keys&#10;                .map((k) =&gt; `${JSON.stringify(k)}: ${fmt(o[k], lvl + 1)}`)&#10;                .map((line) =&gt; pad(lvl + 1) + line)&#10;                .join('\n');&#10;            return `{\n${body}\n${pad(lvl)}}`;&#10;        }&#10;&#10;        // functions/symbol/undefined -&gt; stringify safely&#10;        return JSON.stringify(String(v));&#10;    };&#10;&#10;    return fmt(value, 0);&#10;}&#10;&#10;// Use it in your existing function&#10;export function formatWasmResult(value: unknown): string {&#10;    if (value === undefined || value === null) return '';&#10;    if (typeof value === 'string') return value;&#10;    if (typeof value === 'number' || typeof value === 'boolean' || typeof value === 'bigint') {&#10;        return String(value);&#10;    }&#10;    if (value instanceof Error) return value.message;&#10;&#10;    try {&#10;        return stringifyNoWrapLists(value, 2);&#10;    } catch {&#10;        return String(value);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>